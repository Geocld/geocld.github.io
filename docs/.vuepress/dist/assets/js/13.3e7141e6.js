(window.webpackJsonp=window.webpackJsonp||[]).push([[13],{477:function(t,e,a){"use strict";a.r(e);var s=a(62),n=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("栈(stack)，也称堆栈，在计算机科学领域中，栈是一种线性数据结构，它只能在数据串列或阵列的一端进行入栈(push)和出栈(pop)操作，按照后进先出(LIFO)原理进行运作，一张图表示栈的工作如图1：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://i.imgur.com/yRKp3Ez.png",alt:""}})]),t._v(" "),a("p",[t._v("下面将使用JavaScript实现这一数据结构。")]),t._v(" "),a("p",[t._v("##栈的操作\n根据栈的工作方式，我们定义栈的两个操作：")]),t._v(" "),a("p",[t._v("1."),a("code",[t._v("push(data)")]),t._v(":加入数据，也称入栈。")]),t._v(" "),a("p",[t._v("2."),a("code",[t._v("pop()")]),t._v(":将最近加入的数据移除，也称出栈。")]),t._v(" "),a("p",[t._v("##栈的具体实现\n通过使用JavaScript构造函数和原型的方式实现栈的功能。每个构造函数拥有"),a("code",[t._v("_size")]),t._v("和"),a("code",[t._v("_storage")]),t._v("两个属性。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("function Stack() {\n    this._size = 0;\n    this._storage = {};\n}\n")])])]),a("p",[a("code",[t._v("_storage")]),t._v(": 存储栈的数据，使用对象作为栈数据的集合；")]),t._v(" "),a("p",[a("code",[t._v("_size")]),t._v("： 栈的数据长度，当栈新增加(push)一个数据,时，size长度加1，当栈弹出(pop)一个数据，size长度减1。")]),t._v(" "),a("p",[t._v("有了Stack构造函数，接下来通过原型对象实现push(data)方法（因为push方法时所有栈共有方法，故使用prototype使得该方法共享）。")]),t._v(" "),a("p",[t._v("push(data)方法需要具备以下两个功能：")]),t._v(" "),a("p",[t._v("1.每次增加一个数据，我们希望增加栈的数据长度；")]),t._v(" "),a("p",[t._v("2.每次增加一个数据，我们希望将此数据加在栈的顶端。")]),t._v(" "),a("p",[t._v("具体的代码实现如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("Stack.prototype.push = function(data) {\n    // 增加数据长度\n    var size = this._size++;\n \n    // 将数据加到栈的顶部\n    this._storage[size] = data;\n};\n")])])]),a("p",[t._v("push(data)方法之后就是pop()方法，针对pop()的设计思想是：")]),t._v(" "),a("p",[t._v("1.通过栈的当前的长度获取栈顶数据；")]),t._v(" "),a("p",[t._v("2.删除第一步获得的栈顶数据；")]),t._v(" "),a("p",[t._v("3.栈长度size减1；")]),t._v(" "),a("p",[t._v("4.返回弹出栈的数据。")]),t._v(" "),a("p",[t._v("具体的代码实现如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("Stack.prototype.pop = function() {\n    var size = this._size,\n        deletedData;\nif(size) {\n    deletedData = this._storage[size];\n \n    delete this._storage[size];\n    this.size--;\n \n    return deletedData;\n  }\n};\n")])])]),a("p",[t._v("故JavaScript实现栈功能的完整代码如下：")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v("function Stack() {\n    this._size = 0;\n    this._storage = {};\n}\n \nStack.prototype.push = function(data) {\n    var size = ++this._size;\n    this._storage[size] = data;\n};\n \nStack.prototype.pop = function() {\n    var size = this._size,\n        deletedData;\n \n    if (size) {\n        deletedData = this._storage[size];\n \n        delete this._storage[size];\n        this._size--;\n \n        return deletedData;\n    }\n};\n")])])]),a("p",[t._v("##另一种实现方式\n上面是通过构造函数和原型模式实现了栈的push(data)和pop()操作，实际上，JavaScript的Array已经有现成的push()和pop()方法，通过这两个现成的方法可以轻松实现数据的栈操作。")]),t._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",[a("code",[t._v('    //创建一个数组来模拟堆栈\n    var a=new Array();\n    console.log(a);\n    //push: 在数组的末尾添加一个或更多元素，并返回新的长度\n    console.log("入栈");\n    a.push(1)\n    console.log(a);//-----\x3e1\n    a.push(2);\n    console.log(a);//-----\x3e1,2\n    a.push(3);\n    console.log(a);//-----\x3e1,2,3\n    a.push(4);\n    console.log(a);//-----\x3e1,2,3,4\n    console.log("出栈，后进先出");\n    console.log(a);\n    //pop：从数组中把最后一个元素删除，并返回这个元素的值\n    a.pop();//-----\x3e4\n    console.log(a);\n    a.pop();//-----\x3e3\n    console.log(a);\n    a.pop();//-----\x3e2\n    console.log(a);\n    a.pop();//-----\x3e1\n    console.log(a);\n')])])]),a("p",[t._v("firebug下的运行结果如下：")]),t._v(" "),a("p",[a("img",{attrs:{src:"http://i.imgur.com/zjhUJmO.jpg",alt:""}})]),t._v(" "),a("p",[t._v("参考资料：")]),t._v(" "),a("p",[a("a",{attrs:{href:"http://code.tutsplus.com/articles/data-structures-with-javascript-stack-and-queue--cms-23348",target:"_blank",rel:"noopener noreferrer"}},[t._v("Data Structures With JavaScript: Stack and Queue"),a("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);