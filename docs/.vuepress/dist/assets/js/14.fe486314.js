(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{479:function(e,n,t){"use strict";t.r(n);var s=t(62),o=Object(s.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("p",[e._v("队列(queue),与栈(stack)类似，也是一种线性结构，操作与栈类似，但与栈不同的是，队列使用的是先进先出(FIFO)的操作方式，队列的操作和生活中的排队一样，排队的队伍中，先到的在队伍前排的会先处理，后来排队的后处理，一张图表示如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://i.imgur.com/UpNjASQ.jpg",alt:""}})]),e._v(" "),t("p",[e._v("##队列的操作\n队列的操作和栈非常类似，根据栈的操作，这里定义三个队列操作：")]),e._v(" "),t("p",[e._v("1."),t("code",[e._v("size()")]),e._v(": 队列长度")]),e._v(" "),t("p",[e._v("2."),t("code",[e._v("enqueue(data)")]),e._v(": 添加数据插入队尾。")]),e._v(" "),t("p",[e._v("3."),t("code",[e._v("dequeue()")]),e._v("： 读取队列头节点数据并删除该节点。")]),e._v(" "),t("p",[e._v("可以发现在操作方法上，队列和栈就已经有区别了，队列多了一个计算长度的"),t("code",[e._v("size()")]),e._v("方法，这是因为队列的两端操作有关，后面会进行介绍。")]),e._v(" "),t("p",[e._v("##队列的具体实现\n同样先使用构造函数+原型模式实现队列操作，构造函数需要具备三个属性："),t("code",[e._v("_oldestIndex")]),e._v("，"),t("code",[e._v("_newestIndex")]),e._v("和"),t("code",[e._v("_storage")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("function Queue() {\n    this._oldestIndex = 1;\n    this._newestIndex = 1;\n    this._storage = {};\n}\n")])])]),t("p",[t("code",[e._v("_oldestIndex")]),e._v(": 队列队首元素“指针”；")]),e._v(" "),t("p",[t("code",[e._v("_newestIndex")]),e._v("： 队列队尾元素“指针”；")]),e._v(" "),t("p",[t("code",[e._v("_storage")]),e._v("： 队列的存储空间。")]),e._v(" "),t("h5",[e._v("size()方法")]),e._v("\n计算队列的长度需要使用两个变量`_oldestIndex`和`_newestIndex`，而在栈计算长度是只使用了一个`size`变量，存在这种差异的原因在与两种数据结构的数据出入方式不同，栈的方式为`LIFO`,元素的操作只会在栈顶发生，栈底元素的位置不会变，故只用简单的加减法即可计算出栈的长度。但是队列却不同，正如上图显示的，队列的操作为`FIFO`操作，元素的进出发生在队列的两端，如果只用一个`size`进行简单的加减法操作，我们无法准确获得队列当前`队首`和`队尾`的位置，这时候，就需要使用两个变量(在C语言里就是`指针`)记录`队首`和`队尾`的位置。故队列的`size()`具体实现如下：\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Queue.prototype.size = function() {\n    return this._newestIndex - this._oldestIndex;\n};\n")])])]),t("h5",[e._v("enqueue(data)和dequeue()方法")]),e._v("\n有了`size()`的原理后，`enqueue(data)`和`dequeue()`操作就简单多了。\n"),t("p",[e._v("先是"),t("code",[e._v("enqueue(data)")]),e._v("方法，这个方法的操作会影响两个变量：")]),e._v(" "),t("p",[e._v("1.使用"),t("code",[e._v("_storage")]),e._v("对象存储新加入的元素；")]),e._v(" "),t("p",[e._v("2."),t("code",[e._v("_newestIndex")]),e._v("作为队尾的键值，当新元素入队时，"),t("code",[e._v("_newestIndex")]),e._v("加1，初始值为1。")]),e._v(" "),t("p",[e._v("使用JavaScript实现的具体代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Queue.prototype.enqueue = function(data) {\n    this._storage[this._newestIndex] = data;\n    this._newestIndex++;\n};\n")])])]),t("p",[e._v("接下来是"),t("code",[e._v("dequeue()")]),e._v("操作，该操作有一样有两个变量受影响：")]),e._v(" "),t("p",[e._v("1.使用当前的"),t("code",[e._v("_oldestIndex")]),e._v("作为键值从"),t("code",[e._v("_storage")]),e._v("中删除排在最前面的元素；")]),e._v(" "),t("p",[e._v("2."),t("code",[e._v("_oldestIndex")]),e._v("键值加1，指向当前新的队首元素的位置。")]),e._v(" "),t("p",[e._v("具体实现代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("Queue.prototype.dequeue = function() {\n    var oldestIndex = this._oldestIndex,\n        newestIndex = this._newestIndex,\n        deletedData;\n \t//判断是否存在假溢出、空队列的情况\n    if (oldestIndex !== newestIndex) {\n        deletedData = this._storage[oldestIndex];\n        delete this._storage[oldestIndex];\n        this._oldestIndex++;\n \n        return deletedData;\n    }\n};\n")])])]),t("p",[e._v("故JavaScript实现队列操作的完整代码如下：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v("function Queue() {\n    this._oldestIndex = 1;\n    this._newestIndex = 1;\n    this._storage = {};\n}\n\nQueue.prototype.size = function() {\n    return this._newestIndex - this._oldestIndex;\n};\n \nQueue.prototype.enqueue = function(data) {\n    this._storage[this._newestIndex] = data;\n    this._newestIndex++;\n};\n \nQueue.prototype.dequeue = function() {\n    var oldestIndex = this._oldestIndex,\n        newestIndex = this._newestIndex,\n        deletedData;\n \n    if (oldestIndex !== newestIndex) {\n        deletedData = this._storage[oldestIndex];\n        delete this._storage[oldestIndex];\n        this._oldestIndex++;\n \n        return deletedData;\n    }\n};\n")])])]),t("h5",[e._v("队列的另一种实现方式")]),e._v("\n在栈的操作中，最后使用了数组的`push()`和`pop()`操作模拟了栈的操作，同样的，队列操作也可以，在栈操作的基础上使用`reverse()`可以轻松模拟，具体代码如下：\n"),t("div",{staticClass:"language- extra-class"},[t("pre",[t("code",[e._v('\t//创建一个数组来模拟队列\n    var a=new Array();\n    console.log(a);\n    //push: 在数组的末尾添加一个或更多元素，并返回新的长度\n    console.log("入队");\n    a.push(1)\n    console.log(a);//-----\x3e1\n    a.push(2);\n    console.log(a);//-----\x3e1,2\n    a.push(3);\n    console.log(a);//-----\x3e1,2,3\n    a.push(4);\n    console.log(a);//-----\x3e1,2,3,4\n\tconsole.log("先对数组进行反序操作，保证队首元素在数组的最后");\n\ta = a.reverse();\n\tconsole.log(a)\n    console.log("出队，先进先出");\n    console.log(a);\n    //pop：从数组中把最后一个元素删除，并返回这个元素的值\n    a.pop();//-----\x3e4\n    console.log(a);\n    a.pop();//-----\x3e3\n    console.log(a);\n    a.pop();//-----\x3e2\n    console.log(a);\n    a.pop();//-----\x3e1\n    console.log(a);\n')])])]),t("p",[e._v("在firebug下的输入如下：")]),e._v(" "),t("p",[t("img",{attrs:{src:"http://i.imgur.com/90FhO8B.jpg",alt:""}})]),e._v(" "),t("p",[e._v("##总结\n通过本文和上篇文章("),t("a",{attrs:{href:"http://geocld.github.io/2015/12/28/stack_in_javascript/",target:"_blank",rel:"noopener noreferrer"}},[e._v("JavaScript中的数据结构——栈(Stack)"),t("OutboundLink")],1),e._v(")的介绍，对常用的两种线性数据结构——"),t("code",[e._v("栈")]),e._v("和"),t("code",[e._v("队列")]),e._v("进行了介绍："),t("code",[e._v("栈")]),e._v("存储数据并从最新的元素中进行出栈操作；"),t("code",[e._v("队列")]),e._v("存储数据并从最旧的元素中进行出队操作。并通过JavaScript实现了这两种数据结构的操作。")]),e._v(" "),t("p",[e._v("在具体的实际使用中，"),t("code",[e._v("栈")]),e._v("操作和"),t("code",[e._v("队列")]),e._v("操作比上面所说的复杂很多，但是基本的设计原则如下：如果需要解决的问题是需要对数据进行有序操作，那么优先考虑"),t("code",[e._v("栈")]),e._v("和"),t("code",[e._v("队列")]),e._v("。")]),e._v(" "),t("p",[e._v("参考资料：")]),e._v(" "),t("p",[t("a",{attrs:{href:"http://code.tutsplus.com/articles/data-structures-with-javascript-stack-and-queue--cms-23348",target:"_blank",rel:"noopener noreferrer"}},[e._v("Data Structures With JavaScript: Stack and Queue"),t("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=o.exports}}]);