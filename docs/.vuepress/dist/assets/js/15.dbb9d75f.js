(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{480:function(t,n,e){"use strict";e.r(n);var i=e(62),s=Object(i.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("p",[t._v("在jQuery大量使用的环境下，目前网上的众多jQuery插件也能基本满足要求，但是在项目具体需求下，有时候依旧需要自己造轮子，本文介绍了如何不依赖jQuery等库进行原生JavsScript插件的编写。")]),t._v(" "),e("p",[t._v("##插件需要满足的条件\n一个可复用的插件需要满足以下条件：")]),t._v(" "),e("ol",[e("li",[t._v("插件自身的作用域与用户当前的作用域相互独立，也就是插件内部的私有变量不能影响使用者的环境变量；")]),t._v(" "),e("li",[t._v("插件需具备默认设置参数；")]),t._v(" "),e("li",[t._v("插件除了具备已实现的基本功能外，需提供部分API，使用者可以通过该API修改插件功能的默认参数，从而实现用户自定义插件效果；")]),t._v(" "),e("li",[t._v("插件需提供监听入口，及针对指定元素进行监听，使得该元素与插件响应达到插件效果；")]),t._v(" "),e("li",[t._v("插件支持链式调用。")])]),t._v(" "),e("p",[t._v("以下便针对这四点要求进行逐个讲解，以实现自定义的原生插件。")]),t._v(" "),e("p",[t._v("##1、插件全局函数\n实现私有作用域，最好的办法就是使用闭包。可以把插件当做一个函数，插件内部的变量及函数的私有变量，为了在调用插件后依旧能使用其功能，闭包的作用就是延长函数(插件)内部变量的生命周期，使得插件函数可以重复调用，而不影响用户自身作用域。")]),t._v(" "),e("p",[t._v("故需将插件的所有功能写在一个立即执行函数中：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("(function () {\n\t//插件所有功能都写在这个函数下\n})();\n")])])]),e("p",[t._v("##2、插件默认参数\n插件的主要功能可以总结至几个关键参数，通过这几个关键参数即可修改插件的主要功能，也是第三步API设置的关键参数。")]),t._v(" "),e("p",[t._v("将默认参数放置在全局函数的最前面，参数变量名为options,通过对象字面量进行赋值：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var options = {\n\tkey1: para1,\n\tkey2: para2,\n\tkey3: para3,\n\t...\n\tkeyn: paran\n}\n")])])]),e("p",[t._v("key即为可以插件变量名字，para为该变量对应的值。如我需要编写一个设置颜色的插件，默认颜色为黑色，option应为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var options = {\n\tcolor: '#333333'\n}\n")])])]),e("p",[t._v("编写功能部分时调用方式："),e("code",[t._v("options.color")]),t._v("。")]),t._v(" "),e("p",[t._v("##3、插件API、参数设置和监听\n因为API指向的是使用者，故需要在用户调用插件时将API暴露给用户，因用户API时是通过插件提供的名字进行使用，故将API设置为Object类型，用户就可以通过调用API的key进行使用，具体的代码如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var api = {\n\tconfig: function (ops) {\n\t\t//....\n\t\treturn this;\n\t},\n\tlisten: function listen(elem) {\n\t\t//...\n\t\treturn this;\n\t},\n\tfeature1: function() {\n\t\t//...\n\t},\n\tfeature2: function() {\n\t\t//...\n\t}\n}\nthis.pluginName = api;\n")])])]),e("p",[t._v("上面提供了api的写法示范，该api提供了config以设置自定义参数，listen为插件监听的dom操作，feature为插件的主要功能，使用options参数的功能都要写在api下，注意"),e("code",[t._v("api.config")]),t._v("和"),e("code",[t._v("api.listen")]),t._v("两个函数都应该在最后返回"),e("code",[t._v("this")]),t._v("，以便实现插件的链式调用。")]),t._v(" "),e("p",[t._v("有了上面的框架，针对"),e("code",[t._v("config")]),t._v("设置函数的写法就有了明确的要求：在用户没有传入自定义函数时，默认使用上一节options中的参数，如果用户有设置config参数，使用用户自定义参数：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("config: function (opts) {\n\t//没有参数传入，直接返回默认参数\n\tif(!opts) return options;\n\t//有参数传入，通过key将options的值更新为用户的值\n\tfor(var key in opts) {\n\t\toptions[key] = opts[key];\n\t}\n\treturn this;\n}\n")])])]),e("p",[t._v("针对元素的监听listen，需要对所有符合条件的dom元素进行监听：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("listen: function listen(elem) {\n\t//这里通过typeof设置监听的元素需为字符串调用，实际可根据需要进行更改\n\tif (typeof elem === 'string') {\n\t\t//这里使用ES5的querySelectorAll方法获取dom元素\n\t\tvar elems = document.querySelectorAll(elem),\n\t\t\ti = elems.length;\n\t\t\t//通过递归将listen方法应用在所有的dom元素上\n\t\t\twhile (i--) {\n\t\t\t\tlisten(elems[i]);\n\t\t\t}\n\t\t\treturn\n\t}\n\t//在这里，你可以将插件的部分功能函数写在这里\n\n\treturn this;\n}\n")])])]),e("p",[t._v("在config和listen这两个最基本的API完成后，需要将API与插件的名字结合起来：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("this.pluginName = api;\n")])])]),e("p",[t._v("则最基本的API如下：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("var api = {\n\t//插件参数设定\n\tconfig: function (opts) {\n\t\tif(!opts) return options;\n\t\tfor(var key in opts) {\n\t\t\toptions[key] = opts[key];\n\t\t}\n\t\treturn this;\n\t},\n\t//插件监听\n\tlisten: function listen(elem) {\n\t\tif (typeof elem === 'string') {\n\t\t\tvar elems = document.querySelectorAll(elem),\n\t\t\t\ti = elems.length;\n\t\t\t\twhile (i--) {\n\t\t\t\t\tlisten(elems[i]);\n\t\t\t\t}\n\t\t\t\treturn\n\t\t}\n\t\t//插件功能函数可以写在这\n\t\treturn this;\n\t}\n}\n//将API赋值给插件名字\nthis.pluginName = api;\n")])])]),e("p",[t._v("则用户使用该插件时，调用方式为：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("pluginName.listen('#demo');\n")])])]),e("p",[t._v("如需要自定义参数：")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",[e("code",[t._v("pluginName.config({key: 'para'}).listen('#demo');\n//因为config和listen已经返回this，所有可以这样调用：\npluginName.listen('#demo').config({key: 'para'});\n//还可以这样调用：\npluginName.config({key: 'para'})\n\t\t  .listen('#demo');\n")])])]),e("p",[t._v("##4、结语\n以上介绍了原生插件的基本框架的写法，在我的github上还提供了几个由jQuery插件转化过来的原生插件实例：")]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/Geocld/ColorDivideJS",target:"_blank",rel:"noopener noreferrer"}},[t._v("ColorDivideJS"),e("OutboundLink")],1)]),t._v(" "),e("p",[e("a",{attrs:{href:"https://github.com/Geocld/domzoom.js",target:"_blank",rel:"noopener noreferrer"}},[t._v("domzoom.js"),e("OutboundLink")],1)]),t._v(" "),e("p",[t._v("在这个基础框架基础上，可以扩展出符合项目具体要求的特定插件。同时这样的插件没有其他库依赖，也具有更强的复用性。")]),t._v(" "),e("p",[t._v("（完）")])])}),[],!1,null,null,null);n.default=s.exports}}]);