(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{496:function(t,s,a){"use strict";a.r(s);var e=a(62),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("p",[t._v("如今网络安全性越来越受到重视，普通的HTTP传输已经不能满足严格的信息安全需求，越来越多的用户选择使用HTTPS，那么HTTPS是什么？HTTPS为什么比HTTP安全？HTTPS传输的过程发生了什么？本文将从个人的理解角度努力去给予解答。")]),t._v(" "),a("h2",{attrs:{id:"http和https"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#http和https"}},[t._v("#")]),t._v(" HTTP和HTTPS")]),t._v(" "),a("p",[t._v("HTTP是作为OSI应用层中的协议，当传输信息时，是明文传输的，那么就很容易发生安全问题，任何第三方介入发送端和接收端(俗称中间攻击人)就可以知道传输的内容，从而造成信息泄露问题。在这种情况下就诞生了HTTPS，HTTPS并不是一个全新的协议，而是HTTP+SSL/STL。SSL全称Secure Sockets Layer，他是网景公司发明的用来解决HTTP协议使用明文传输信息造成的信息安全泄露问题而发明出来的协议，后来SSL得到广泛使用，成了互联网的一个标准，后改名为TLS(Transport Layer Security)，中文名叫做：“传输层安全协议”。")]),t._v(" "),a("p",[t._v("SSL/TSL位于HTTP和TCP之间，HTTP需要传输的信息通过SSL/STL加密后，再传输到TCP进行传输，接收到的信息也是先经过SSL/STL解密再回到HTTP，如此一来使用HTTPS传递信息就不再是明文传输了。")]),t._v(" "),a("h2",{attrs:{id:"一些基本概念"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一些基本概念"}},[t._v("#")]),t._v(" 一些基本概念")]),t._v(" "),a("p",[t._v("在讨论HTTPS如何加密传输之前，我们需要先做一些功课来了解相关概念。涉及到HTTPS加密的概念有："),a("code",[t._v("公钥")]),t._v("，"),a("code",[t._v("私钥")]),t._v("，"),a("code",[t._v("对称加密")]),t._v("，"),a("code",[t._v("非对称加密")]),t._v("，下面一个个进行介绍:")]),t._v(" "),a("ul",[a("li",[a("p",[a("code",[t._v("公钥")]),t._v("：公开的密钥，任何人都可以知道这个秘钥及其解密算法。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("私钥")]),t._v("：不公开密钥，一般是企业服务器内部私有。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("对称加密")]),t._v("：加密使用的密钥和解密使用的密钥是相同的，不区分"),a("code",[t._v("公钥")]),t._v("和"),a("code",[t._v("私钥")]),t._v("，实现对称加密需要通信双方先协商好一把密钥，用于在通信过程中解密加密信息，对称加密的特点是加密、解密的效率比较高。")])]),t._v(" "),a("li",[a("p",[a("code",[t._v("非对称加密")]),t._v("：加密使用的密钥和解密使用的密钥是不相同的。也就是说使用"),a("code",[t._v("公钥")]),t._v("加密的内容必须使用"),a("code",[t._v("私钥")]),t._v("解密；使用"),a("code",[t._v("私钥")]),t._v("加密的内容必须使用"),a("code",[t._v("公钥")]),t._v("解密，非对称加密的加密、解密效率比对称加密低，下面是用Python的rsa模块实现一个非对称加密、解密的例子：")]),t._v(" "),a("div",{staticClass:"language-python line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-python"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" rsa\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("pub_key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" priv_key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" rsa"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("newkeys"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token number"}},[t._v("256")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),t._v(" pub_key "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 公钥 PublicKey(95486814448401066618225108230378658095818087913775724964-908995323017037455049, 65537)")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),t._v(" priv_key "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 私钥 PrivateKey(95486814448401066618225108230378658095818087913775724964-908995323017037455049, 65537, 74777145397794954637032015955990110399713179956878421347933123063061797903213, 81554253653315495438198948774508679231171, 1170837941259476644908380749633106819)")]),t._v("\ncrypto "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" rsa"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("encrypt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'hello world'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" pub_key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 公钥对“hello world”进行加密")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),t._v(" crypto "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用公钥加密后的内容 ^���� \tܹ��EXz�~J�pX   ���/7L��")]),t._v("\ndecrypt "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" rsa"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("decrypt"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("crypto"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" priv_key"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 使用私钥解密")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("print")]),t._v(" decrypt "),a("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# hello world")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br"),a("span",{staticClass:"line-number"},[t._v("7")]),a("br"),a("span",{staticClass:"line-number"},[t._v("8")]),a("br")])])])]),t._v(" "),a("h2",{attrs:{id:"https的通信过程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https的通信过程"}},[t._v("#")]),t._v(" HTTPS的通信过程")]),t._v(" "),a("p",[t._v("假设一个服务器端支持HTTPS访问（即已经配置了SSL证书，该证书得到公开认可，这个证书上会有一对公钥和私钥），那么从客户端使用HTTPS发起请求到客户端、服务器端稳定通信的流程如下:")]),t._v(" "),a("p",[t._v("##1.客户端发起请求")]),t._v(" "),a("p",[t._v("客户端发起HTTPS连接请求，告诉服务器要以HTTPS的方式进行通信。")]),t._v(" "),a("p",[t._v("##2.服务器端传送证书")]),t._v(" "),a("p",[t._v("服务器端收到客户端的请求后，便会向客户端传送包含了公钥、颁发机构、过期日期等内容的数字证书，便于后面进行非对称加密使用。")]),t._v(" "),a("p",[t._v("##3.客户端验证证书并发送签名信息")]),t._v(" "),a("p",[t._v('客户端收到服务器端发送的证书后，为了证明这个证书是"真正的"服务器端发出且可信的，而不是中间攻击者发出的，需要向CA机构服务器验证这个证书是否可信，若这个证书是CA机构不认可的，那么此时会发出警告，通知客户端此次通信存在安全问题:')]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.ax2x.com/2017/09/30/9FsE6.jpg",alt:"1"}})]),t._v(" "),a("p",[t._v("如果数字证书验证通过，那么客户端需要验证当前跟他通信的服务器有私钥，此时客户端会生成一个随机数，使用证书上的公钥进行加密，这个随机数称之为"),a("code",[t._v("数字签名")]),t._v("。")]),t._v(" "),a("p",[t._v("##4.服务器端解密数字签名，并回传验证信息")]),t._v(" "),a("p",[t._v("服务器端收到公钥加密的数字签名后，便可使用私钥进行解密得到客户端的数字签名，随后该数字签名用私钥进行加密，作为一个验证信息回馈至客户端。")]),t._v(" "),a("p",[t._v("##5.客户端验证服务器私钥")]),t._v(" "),a("p",[t._v("服务器使用私钥加密的签名信息发送到客户端后，根据非对称加密的原则，客户端可以使用公钥对这个加密信息进行解密，解密得到的签名信息再跟第三步的签名信息做比较，如果二者一致，那么证明当前通信服务器拥有私钥并且当前通信没有中间攻击者篡改通信信息，接下来可以愉快的进行通信了。此时客户端再次生成一个随机数，使用公钥加密后发送至服务器端，这个随机数作为接下来对称加密的密钥。")]),t._v(" "),a("p",[t._v("##6.建立对称加密通信")]),t._v(" "),a("p",[t._v("服务器端收到第五步客户端发出的加密随机数后，使用私钥解密，那么此时，客户端和服务器端都拥有一个相同的随机数，客户端和服务器端都可以用对称加密算法来加密和解密通信内容了。")]),t._v(" "),a("p",[t._v("以上六个流程，第2-5步都是非对称加密，由于服务器私钥不对外公开，即使有中间攻击者对通信信息作出篡改或冒充，客户端和服务器端都能及时发现，从而保证第6步的对称加密密钥不落入第三方手中，整个流程如下图所示:")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://s1.ax2x.com/2017/09/30/9FCGa.jpg",alt:"2"}})]),t._v(" "),a("h2",{attrs:{id:"总结"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[t._v("#")]),t._v(" 总结")]),t._v(" "),a("p",[t._v("HTTPS的加密通信流程基本就如上所述，涉及到的概念比较多，也比较抽象，建议反复阅读。事实上HTTPS相关的加密算法和通信过程要复杂的多，如果需要深入了解下去，还需要了解证书、SSL加密方式等一系列知识。")]),t._v(" "),a("p",[t._v("（完）")]),t._v(" "),a("p",[t._v("参考:")]),t._v(" "),a("p",[a("a",{attrs:{href:"https://www.zybuluo.com/mikumikulch/note/255232",target:"_blank",rel:"noopener noreferrer"}},[t._v("通俗易懂的解释HTTPS"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("图解SSL/TLS协议"),a("OutboundLink")],1)]),t._v(" "),a("p",[a("a",{attrs:{href:"http://www.cnblogs.com/JeffreySun/archive/2010/06/24/1627247.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("数字证书原理"),a("OutboundLink")],1)])])}),[],!1,null,null,null);s.default=r.exports}}]);